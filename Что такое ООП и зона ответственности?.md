## Что такое ООП? 

Многие люди сразу начнуть рассказывать про три головы этого страшоного и многими не любимого дракона: Инкапсуляцию, Полиморфизм и Наследование. Я даже слышал, что существуют легенды про четвертую. 

Но для меня, отвечая на этот вопрос, сначала очень хочется сказать про принцип "Разделения ответственности" (SoC) или, можно сказать, Зону ответственности. Потому что, как по мне, оно гораздо первоочереднее и фундаментальнее. А те три страшные и непонятные штуки рождаются из нее. И вообще программирование (по крайней мере современное), в большой степени именно про "ответственность" ~~(и безответственность бизнеса и миллениалов)~~, а не про ООП, ФП и фреймворки.

## Что же такое Разделение ответственности?

### По сути все программирование состоит из определенных сущностей и связей между ними. 

Сущности - это не объекты типа мяча и собаки в ООП, а кодовые - функции, классы, модули. Они взаимодействуют друг с другом, имеют связи, интерфейсы между собой. А главное, каждая делает что-то **свое**.
И когда мы пишем код, надо представлять что и как используется сейчас, может и будет использоваться в будущем.

### Нужно понимать что за что отвечает и как взаимодействует со всем остальным.

Это и есть зона ответственности каждого конкретного куска кода, будь то функция или класс. Фактически - это интерфейсы функций, входные параметры и возвращаемые значения. 

Но на более высоком уровне - это именно то, что делает функция, какую часть логики приложения она выполняет и реализует. И чуть ли не самое главное в программировании на сегодняшний день (когда десятки разработчиков пишут кучу разного кода одного приложения) - понимать что именно делает этот конкретный кусок кода, понимать его **зону ответственности**.

### Это разделение и по **слоям** приложения (обычно рисуется по вертикали) и по **функциональности** (по горизонтали).
	
Потому что любой паттерн (буть то MVC или фабрика или что угодно еще) - будет предоставлять шаблоны неких зон ответственности, которые часто встречаются в приложениях. Например, MVC нам говорит о том, где у нас Графический интерфейс, где Бизнес-логика, а где Инфраструктура приложения, управляющая и связывающая первые два слоя. А классические паттерны Банды Четырех больше про горизонтальное разделение кода - то, как должны взаимодействовать друг с другом близлежащие модули приложения.

Современный хайп по микросервисам - в общем то как раз про это. "А давайте вынесем каждую отдельную функциональность в свой угол". Это чтобы неповадно было лезть куда попало своими паклями, лишних зависимостей избегать и масштабировать легче было. 
Но это как понимаете, просто инструмент, а как его применишь - все равно от головы зависит (и молотком шурупы с пальцами забивать можно, и на Haskell говнокод написать). Возможно, сложнее, конечно, но тем не менее.


> Забавно, что существует два термина, "Разделение ответственности" (SoC: Separation of Concerns) и принцип "Единственной обязанности" (SRP: Single Responsibility Principle).

> Первый был придуман Дейкстрой вообще про науку во времена императивного программирования (если не раньше - 1974), более того, в тот же момент он использовал и словосочетание "Single Responsibility", а к программированию его применили впервые к функциям (1989). Второй был описан Робертом Мартином во времена ООП и в отношении классов.

> Но на самом деле разницы принципиальной нет - суть одна и эта идея актуальна для любых частей кода и приложения.
> По сути - это принцип "Разделяй и властвуй" откуда то из древности и философии.

> И вообще все фундаментальные идеи в программировании пришли из философии - так что порой лучше почитать что-нибудь оттуда, чем изучать новый фреймворк в 2KXX году.


## Принцип единой ответственности

Дак как же понять за что должна отвечать наша новая функция или класс, и нужны ли они нам, а может нужны сразу три или пять вместо одного?
Ну тут думать надо, куда без этого. Но может помочь такая идея, что каждая такая сущность должна отвечать только за какое-то **одно** действие. И это не значит, что в одном классе должна быть одна функция, в которой только один оператор ++. Это значит, что роль у сущности должна быть одна. (Никто же не любит, когда программистов просят поменять в принтере картридж или настроить чтобы компьютер "работал по-быстрее"). Вот тут так же. 

### Одна роль должна быть у всего, и каждый должен отвечать и заниматься только одним делом и знать все об этом. 
###И в то же время никто не должен лезть не в свое дело.

> А еще DRY (Don't Repeat Yourself) очень помогает (но не всегда, если вдруг дублирования нет, а разделить было бы неплохо).

И вот, например, нужен вам класс, который запросы отправляет куда-нибудь. И в нем пачку функций - каждая отправляет свой запрос. Сделали. 
Но в каждой заного создается Request-Response (всякие XHR, ajax, curl и тому подобное) - значит это можно вынести в отдельную функцию создания запроса (это как раз DRY), а еще лучше вообще в отдельный класс - потому что, скорее всего у вас будет еще какой-нибудь класс, который запросы еще куда-то отправляет, и вам там это тоже пригодится.

А потом смотрите - и что-то куча всего в одном классе: и пользователи, и товары, и настройки. А неплохо было бы это тоже разнести в отдельные классы - разное все-таки, а не одно. При этом скорее всего в этих классах не должно быть какой-то логики приложения, а просто голое получение данных, потому что не должна ничего знать прослойка к чужому серверу о логике вашего приложения. То как вы работаете у себя уже с этими контактами и товарами - задача вообще другого слоя.

Более того - даже классы сущностей (контакты/товары) не рекомендуется иметь одни и те же. То есть то, что вы получаете с одного сервера - это одно. А то с чем работаете у себя - другое. Это дополнительно поможет при поддержке и рефакторинге, уменьшив **зависимость между модулями**. 

Конечно для этого могут понадобиться свои трансформеры (хотя я терпеть не могу перегонку из одного в порожнее), или какие-то другие способы/прослойки/интерфейсы, чтобы разграничить работу с разными сущностями.

## Связи внутри и снаружи

И тут мы коснулись интересного момента - **зависимости между модулями** и то, что их кол-во надо уменьшать - а зачем и кому это вообще надо?

Дак вот есть еще одна такая идея:

### Взаимодействие между модулями (Coupling - сцепленность) должно быть минимальна, а внутри модуля (Cohesion - связность) - максимальна. 

В целом, это должно приводить к тому, что модули/классы/функции должны быть меньше, внутри они должны делать что-то одно и хорошо об этом знать, чтобы был максимально легкий доступ к данным/функциям.
А минимальная сцепленность между сущностями обеспечивает более легкое использование (меньше параметров передавать надо), меньше зависимостей (а значит меньше вероятность что-то сломать при рефакторинге и добавлении функционала), и просто более легкое восприятие кода (легче же прочитать 5-10-строчную функцию, чем 50ти; и файл в 100-200 строк, чем в 1000+).

На уровне функций это должно приводить к тому, что существуют функции, которые описывают логику (в них нет особо каких-то явных вычислений и даже работы с циклами). Они просто вызывают другие функции, и ты их читаешь как текст (поэтому и именовать надо нормально, чтобы читать было понятно) - они и могут быть побольше размером.

А другие функции, в которых какие-то вычисления, получение/обработка данных и все такое - они не должны особо другие функции вызывать, и размера быть небольшого, чтобы быстро понять код, если надо. 

### А в основном - из названия должно быть понятно, что функция делает.

Чтобы вы не сидели и не думали что происходит в огромной функции под названием `createApplication();`, в которой и циклы, и работа с данными и чего только нет.
А читали код, быстро его исправляли и так же быстро "херачили фичи", не убивая при этом поддерживаемость приложения - потому что бизнесу это же надо? Много фич, стабильное приложение и довольные пользователи, которые с радостью заплатят денег за такое прекрасное приложение (а прекрасно оно потому, что то, что прекрасно внутри - прекрасно и снаружи).


## И все-таки, а что там про ООП-то?

Возвращаясь к оригинальному вопросу - "А что же такое ООП?". Дак вот ООП это такой относительно удобный инструмент, который позволяет довольно неплохо выделять кодовые сущности по их роли и ответственности. А так же иметь хорошую связность функциональности и данных прямо внутри одного объекта. 

ООП при желании и умении позволяет разграничить публичный и приватный интерфейс; легко создать композицию, либо наследование; создать полморфизм с помощью абстрактных классов и интерфейсов.

Последнее, особенно удобно, когда у вас есть некоторые **разные** модули, которые решают схожую задачу (например генерируют XML/CSV файл на основе каких-то данных, или работают с разными схожими системами). 

И вроде системы разные, а интерфейс использования для нашего приложения/модуля очень похож и можно его свести к одному. В таком случае и делают `interface` для описания, `abstract class` для реализации общей логики, и для каждого случая делают отдельную реализацию.

Всякие фабрики, мосты и прослойки - это все следствие и они сами у вас родятся, если понимать что такое "зона ответственность" каждого элемента в коде и следовать базовым принципам типа **DRY**, **KISS**, **YAGNI** и **SOLID**.



